// 作用域

// 1-变量声明的关键字
//          强制初始化    允许修改    跨块访问    跨函数访问
// var       不强制        允许       支持        不支持
// let       不强制        允许      不支持       不支持
// const      强制        不允许     不支持       不支持


// 2-函数作用域
// 函数参数和函数内部声明的变量称为局部变量
// 局部变量在函数作用域内会覆盖同名的全局变量,不允许跨函数访问
var v = 1;
function f(){
    var v = 2;    // 局部变量,覆盖全局变量v,仅函数内访问
    console.log(v);
}
f()     // 2(函数内调用v,调用的是局部变量)
v       // 1(函数外调用v,调用的是全局变量)


// 3-块级作用域
// 块级作用域使用{}显式定义,let和const定义符合对象都存在块级作用域
// 块级作用域内可以使用let定义局部变量覆盖全局变量,但不能在相同作用域内重复使用let定义局部变量
{{{{
    let insane = 'Hello World';
    {let insane = 'Hello World'}
}}}}

// var不存在块级作用域的概念
// 在{}中使用var定义变量仍然属于全局变量,只有在函数中使用var定义才属于局部变量
if (true) {
    var x = 5;        // 全局变量,允许跨块访问
}


// 3-1 for循环的双作用域
// ①初始化语句所在的父作用域:
//  初始化语句的作用域中,如果使用var定义循环变量,退出循环后变量仍然生效
//  通常使用let定义循环变量,退出循环后变量脱离块作用域不再生效
// ②循环体所在的子作用域:
//  循环体的作用域中可以直接读写循环变量的值,也可以使用let定义同名的局部变量
//  每次进入循环体都会覆盖父作用域的循环变量使得外部值不受影响

// for循环双作用域的特点在于:
//  ①子作用域可以访问父作用域的循环变量
//  ②作用域中可以重复使用let覆盖同名变量
for(var i = 0; i < 10; i++){
    let i = 1;
    console.log(i);     // i = 1
}                       // i为全局变量,仍然生效,i=9

for(let i = 0; i < 10; i++){
    let i = 2;
    console.log(i);    // i = 2
}                      // i为局部变量,无法访问

// 3-2 变量提升
// ①使用let和const声明变量:不存在变量提升,变量只有在声明后才能被使用
// ②使用var声明变量:存在变量提升，变量可以在声明之前使用
// 变量的初始化不能被提升,因此在声明和初始化变量之前,访问该变量始终返回undefined
console.log(foo);       // undefined
var foo = 2;

console.log(bar);       // 报错->ReferenceError
let bar = 2;

// 3-3 暂时性死区
// 块作用域对let和const声明的变量形成封闭作用域,在声明语句之前执行这些变量相关的操作都会报错
// 暂时性死区的本质是:进入当前作用域时,变量处于存在但不可获取的状态，变量声明后才可以获取和使用
var tmp = 123;
if (true) {
    // 进入死区,内部定义了同名tmp,因此暂时禁止tmp的访问
    tmp = 'abc';         // 报错,未到声明语句处
    console.log(tmp);    // 报错,未到声明语句处
    let tmp;             // 声明结束,退出死区,但未初始化->undefined
    tmp = 123;           // ->123
}


// 4-链式作用域和闭包
// 链式作用域:在函数内部定义函数时,内部的函数属于局部变量,可以访问到外部函数的所有变量
// 当链式作用域有多层时,最底层的函数可以依次向上查找,访问到所有层次上定义的变量
function f1() {
    var n = 999;
    function f2() {
        console.log(n);     // 访问到外部f1()的局部变量n->999
    }
}

// 闭包:当内层函数返回外层函数作用域中的局部变量时,函数外部可以获取到函数内部的变量值
// 由于内部变量依然处于被访问的状态,外层函数的运行环境不会被垃圾回收,无法从内存释放
// 使用闭包的情况下,外层函数的每次运行都会生成保存新运行环境的闭包,占用资源会越来越多
function createIncrementor(start) {
    return function () {
        // 识别闭包的特征:内层函数返回外层函数定义的局部变量
        return start++;
    };
}
var inc = createIncrementor(5);
inc()   // start = 5,此时inc = start++(后续同理)
inc()   // start = 6
inc()   // start = 7
